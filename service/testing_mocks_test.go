// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package service_test

import (
	"encoding/json"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gorilla/sessions"
	"github.com/sirupsen/logrus"
	"github.com/wepala/weos-controller/service"
	"net/http"
	"sync"
)

// Ensure, that ServiceInterfaceMock does implement service.ServiceInterface.
// If this is not the case, regenerate this file with moq.
var _ service.ServiceInterface = &ServiceInterfaceMock{}

// ServiceInterfaceMock is a mock implementation of service.ServiceInterface.
//
//     func TestSomethingThatUsesServiceInterface(t *testing.T) {
//
//         // make and configure a mocked service.ServiceInterface
//         mockedServiceInterface := &ServiceInterfaceMock{
//             ConfigurePathFunc: func(path string, config *service.PathConfig) error {
// 	               panic("mock out the ConfigurePath method")
//             },
//             GetConfigFunc: func() *openapi3.Swagger {
// 	               panic("mock out the GetConfig method")
//             },
//             GetGlobalMiddlewareConfigFunc: func() ([]*service.MiddlewareConfig, error) {
// 	               panic("mock out the GetGlobalMiddlewareConfig method")
//             },
//             GetHandlersFunc: func(config *service.PathConfig, mockHandler http.Handler) ([]http.HandlerFunc, error) {
// 	               panic("mock out the GetHandlers method")
//             },
//             GetPathConfigFunc: func(path string, operation string) (*service.PathConfig, error) {
// 	               panic("mock out the GetPathConfig method")
//             },
//         }
//
//         // use mockedServiceInterface in code that requires service.ServiceInterface
//         // and then make assertions.
//
//     }
type ServiceInterfaceMock struct {
	// ConfigurePathFunc mocks the ConfigurePath method.
	ConfigurePathFunc func(path string, config *service.PathConfig) error

	// GetConfigFunc mocks the GetConfig method.
	GetConfigFunc func() *openapi3.Swagger

	// GetGlobalMiddlewareConfigFunc mocks the GetGlobalMiddlewareConfig method.
	GetGlobalMiddlewareConfigFunc func() ([]*service.MiddlewareConfig, error)

	// GetHandlersFunc mocks the GetHandlers method.
	GetHandlersFunc func(config *service.PathConfig, mockHandler http.Handler) ([]http.HandlerFunc, error)

	// GetPathConfigFunc mocks the GetPathConfig method.
	GetPathConfigFunc func(path string, operation string) (*service.PathConfig, error)

	// calls tracks calls to the methods.
	calls struct {
		// ConfigurePath holds details about calls to the ConfigurePath method.
		ConfigurePath []struct {
			// Path is the path argument value.
			Path string
			// Config is the config argument value.
			Config *service.PathConfig
		}
		// GetConfig holds details about calls to the GetConfig method.
		GetConfig []struct {
		}
		// GetGlobalMiddlewareConfig holds details about calls to the GetGlobalMiddlewareConfig method.
		GetGlobalMiddlewareConfig []struct {
		}
		// GetHandlers holds details about calls to the GetHandlers method.
		GetHandlers []struct {
			// Config is the config argument value.
			Config *service.PathConfig
			// MockHandler is the mockHandler argument value.
			MockHandler http.Handler
		}
		// GetPathConfig holds details about calls to the GetPathConfig method.
		GetPathConfig []struct {
			// Path is the path argument value.
			Path string
			// Operation is the operation argument value.
			Operation string
		}
	}
	lockConfigurePath             sync.RWMutex
	lockGetConfig                 sync.RWMutex
	lockGetGlobalMiddlewareConfig sync.RWMutex
	lockGetHandlers               sync.RWMutex
	lockGetPathConfig             sync.RWMutex
}

// ConfigurePath calls ConfigurePathFunc.
func (mock *ServiceInterfaceMock) ConfigurePath(path string, config *service.PathConfig) error {
	if mock.ConfigurePathFunc == nil {
		panic("ServiceInterfaceMock.ConfigurePathFunc: method is nil but ServiceInterface.ConfigurePath was just called")
	}
	callInfo := struct {
		Path   string
		Config *service.PathConfig
	}{
		Path:   path,
		Config: config,
	}
	mock.lockConfigurePath.Lock()
	mock.calls.ConfigurePath = append(mock.calls.ConfigurePath, callInfo)
	mock.lockConfigurePath.Unlock()
	return mock.ConfigurePathFunc(path, config)
}

// ConfigurePathCalls gets all the calls that were made to ConfigurePath.
// Check the length with:
//     len(mockedServiceInterface.ConfigurePathCalls())
func (mock *ServiceInterfaceMock) ConfigurePathCalls() []struct {
	Path   string
	Config *service.PathConfig
} {
	var calls []struct {
		Path   string
		Config *service.PathConfig
	}
	mock.lockConfigurePath.RLock()
	calls = mock.calls.ConfigurePath
	mock.lockConfigurePath.RUnlock()
	return calls
}

// GetConfig calls GetConfigFunc.
func (mock *ServiceInterfaceMock) GetConfig() *openapi3.Swagger {
	if mock.GetConfigFunc == nil {
		panic("ServiceInterfaceMock.GetConfigFunc: method is nil but ServiceInterface.GetConfig was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetConfig.Lock()
	mock.calls.GetConfig = append(mock.calls.GetConfig, callInfo)
	mock.lockGetConfig.Unlock()
	return mock.GetConfigFunc()
}

// GetConfigCalls gets all the calls that were made to GetConfig.
// Check the length with:
//     len(mockedServiceInterface.GetConfigCalls())
func (mock *ServiceInterfaceMock) GetConfigCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetConfig.RLock()
	calls = mock.calls.GetConfig
	mock.lockGetConfig.RUnlock()
	return calls
}

// GetGlobalMiddlewareConfig calls GetGlobalMiddlewareConfigFunc.
func (mock *ServiceInterfaceMock) GetGlobalMiddlewareConfig() ([]*service.MiddlewareConfig, error) {
	if mock.GetGlobalMiddlewareConfigFunc == nil {
		panic("ServiceInterfaceMock.GetGlobalMiddlewareConfigFunc: method is nil but ServiceInterface.GetGlobalMiddlewareConfig was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetGlobalMiddlewareConfig.Lock()
	mock.calls.GetGlobalMiddlewareConfig = append(mock.calls.GetGlobalMiddlewareConfig, callInfo)
	mock.lockGetGlobalMiddlewareConfig.Unlock()
	return mock.GetGlobalMiddlewareConfigFunc()
}

// GetGlobalMiddlewareConfigCalls gets all the calls that were made to GetGlobalMiddlewareConfig.
// Check the length with:
//     len(mockedServiceInterface.GetGlobalMiddlewareConfigCalls())
func (mock *ServiceInterfaceMock) GetGlobalMiddlewareConfigCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetGlobalMiddlewareConfig.RLock()
	calls = mock.calls.GetGlobalMiddlewareConfig
	mock.lockGetGlobalMiddlewareConfig.RUnlock()
	return calls
}

// GetHandlers calls GetHandlersFunc.
func (mock *ServiceInterfaceMock) GetHandlers(config *service.PathConfig, mockHandler http.Handler) ([]http.HandlerFunc, error) {
	if mock.GetHandlersFunc == nil {
		panic("ServiceInterfaceMock.GetHandlersFunc: method is nil but ServiceInterface.GetHandlers was just called")
	}
	callInfo := struct {
		Config      *service.PathConfig
		MockHandler http.Handler
	}{
		Config:      config,
		MockHandler: mockHandler,
	}
	mock.lockGetHandlers.Lock()
	mock.calls.GetHandlers = append(mock.calls.GetHandlers, callInfo)
	mock.lockGetHandlers.Unlock()
	return mock.GetHandlersFunc(config, mockHandler)
}

// GetHandlersCalls gets all the calls that were made to GetHandlers.
// Check the length with:
//     len(mockedServiceInterface.GetHandlersCalls())
func (mock *ServiceInterfaceMock) GetHandlersCalls() []struct {
	Config      *service.PathConfig
	MockHandler http.Handler
} {
	var calls []struct {
		Config      *service.PathConfig
		MockHandler http.Handler
	}
	mock.lockGetHandlers.RLock()
	calls = mock.calls.GetHandlers
	mock.lockGetHandlers.RUnlock()
	return calls
}

// GetPathConfig calls GetPathConfigFunc.
func (mock *ServiceInterfaceMock) GetPathConfig(path string, operation string) (*service.PathConfig, error) {
	if mock.GetPathConfigFunc == nil {
		panic("ServiceInterfaceMock.GetPathConfigFunc: method is nil but ServiceInterface.GetPathConfig was just called")
	}
	callInfo := struct {
		Path      string
		Operation string
	}{
		Path:      path,
		Operation: operation,
	}
	mock.lockGetPathConfig.Lock()
	mock.calls.GetPathConfig = append(mock.calls.GetPathConfig, callInfo)
	mock.lockGetPathConfig.Unlock()
	return mock.GetPathConfigFunc(path, operation)
}

// GetPathConfigCalls gets all the calls that were made to GetPathConfig.
// Check the length with:
//     len(mockedServiceInterface.GetPathConfigCalls())
func (mock *ServiceInterfaceMock) GetPathConfigCalls() []struct {
	Path      string
	Operation string
} {
	var calls []struct {
		Path      string
		Operation string
	}
	mock.lockGetPathConfig.RLock()
	calls = mock.calls.GetPathConfig
	mock.lockGetPathConfig.RUnlock()
	return calls
}

// Ensure, that PluginInterfaceMock does implement service.PluginInterface.
// If this is not the case, regenerate this file with moq.
var _ service.PluginInterface = &PluginInterfaceMock{}

// PluginInterfaceMock is a mock implementation of service.PluginInterface.
//
//     func TestSomethingThatUsesPluginInterface(t *testing.T) {
//
//         // make and configure a mocked service.PluginInterface
//         mockedPluginInterface := &PluginInterfaceMock{
//             AddConfigFunc: func(config json.RawMessage) error {
// 	               panic("mock out the AddConfig method")
//             },
//             AddLoggerFunc: func(logger logrus.Ext1FieldLogger)  {
// 	               panic("mock out the AddLogger method")
//             },
//             AddPathConfigFunc: func(handler string, config json.RawMessage) error {
// 	               panic("mock out the AddPathConfig method")
//             },
//             AddSessionFunc: func(session sessions.Store)  {
// 	               panic("mock out the AddSession method")
//             },
//             GetHandlerByNameFunc: func(name string) http.HandlerFunc {
// 	               panic("mock out the GetHandlerByName method")
//             },
//         }
//
//         // use mockedPluginInterface in code that requires service.PluginInterface
//         // and then make assertions.
//
//     }
type PluginInterfaceMock struct {
	// AddConfigFunc mocks the AddConfig method.
	AddConfigFunc func(config json.RawMessage) error

	// AddLoggerFunc mocks the AddLogger method.
	AddLoggerFunc func(logger logrus.Ext1FieldLogger)

	// AddPathConfigFunc mocks the AddPathConfig method.
	AddPathConfigFunc func(handler string, config json.RawMessage) error

	// AddSessionFunc mocks the AddSession method.
	AddSessionFunc func(session sessions.Store)

	// GetHandlerByNameFunc mocks the GetHandlerByName method.
	GetHandlerByNameFunc func(name string) http.HandlerFunc

	// calls tracks calls to the methods.
	calls struct {
		// AddConfig holds details about calls to the AddConfig method.
		AddConfig []struct {
			// Config is the config argument value.
			Config json.RawMessage
		}
		// AddLogger holds details about calls to the AddLogger method.
		AddLogger []struct {
			// Logger is the logger argument value.
			Logger logrus.Ext1FieldLogger
		}
		// AddPathConfig holds details about calls to the AddPathConfig method.
		AddPathConfig []struct {
			// Handler is the handler argument value.
			Handler string
			// Config is the config argument value.
			Config json.RawMessage
		}
		// AddSession holds details about calls to the AddSession method.
		AddSession []struct {
			// Session is the session argument value.
			Session sessions.Store
		}
		// GetHandlerByName holds details about calls to the GetHandlerByName method.
		GetHandlerByName []struct {
			// Name is the name argument value.
			Name string
		}
	}
	lockAddConfig        sync.RWMutex
	lockAddLogger        sync.RWMutex
	lockAddPathConfig    sync.RWMutex
	lockAddSession       sync.RWMutex
	lockGetHandlerByName sync.RWMutex
}

// AddConfig calls AddConfigFunc.
func (mock *PluginInterfaceMock) AddConfig(config json.RawMessage) error {
	if mock.AddConfigFunc == nil {
		panic("PluginInterfaceMock.AddConfigFunc: method is nil but PluginInterface.AddConfig was just called")
	}
	callInfo := struct {
		Config json.RawMessage
	}{
		Config: config,
	}
	mock.lockAddConfig.Lock()
	mock.calls.AddConfig = append(mock.calls.AddConfig, callInfo)
	mock.lockAddConfig.Unlock()
	return mock.AddConfigFunc(config)
}

// AddConfigCalls gets all the calls that were made to AddConfig.
// Check the length with:
//     len(mockedPluginInterface.AddConfigCalls())
func (mock *PluginInterfaceMock) AddConfigCalls() []struct {
	Config json.RawMessage
} {
	var calls []struct {
		Config json.RawMessage
	}
	mock.lockAddConfig.RLock()
	calls = mock.calls.AddConfig
	mock.lockAddConfig.RUnlock()
	return calls
}

// AddLogger calls AddLoggerFunc.
func (mock *PluginInterfaceMock) AddLogger(logger logrus.Ext1FieldLogger) {
	if mock.AddLoggerFunc == nil {
		panic("PluginInterfaceMock.AddLoggerFunc: method is nil but PluginInterface.AddLogger was just called")
	}
	callInfo := struct {
		Logger logrus.Ext1FieldLogger
	}{
		Logger: logger,
	}
	mock.lockAddLogger.Lock()
	mock.calls.AddLogger = append(mock.calls.AddLogger, callInfo)
	mock.lockAddLogger.Unlock()
	mock.AddLoggerFunc(logger)
}

// AddLoggerCalls gets all the calls that were made to AddLogger.
// Check the length with:
//     len(mockedPluginInterface.AddLoggerCalls())
func (mock *PluginInterfaceMock) AddLoggerCalls() []struct {
	Logger logrus.Ext1FieldLogger
} {
	var calls []struct {
		Logger logrus.Ext1FieldLogger
	}
	mock.lockAddLogger.RLock()
	calls = mock.calls.AddLogger
	mock.lockAddLogger.RUnlock()
	return calls
}

// AddPathConfig calls AddPathConfigFunc.
func (mock *PluginInterfaceMock) AddPathConfig(handler string, config json.RawMessage) error {
	if mock.AddPathConfigFunc == nil {
		panic("PluginInterfaceMock.AddPathConfigFunc: method is nil but PluginInterface.AddPathConfig was just called")
	}
	callInfo := struct {
		Handler string
		Config  json.RawMessage
	}{
		Handler: handler,
		Config:  config,
	}
	mock.lockAddPathConfig.Lock()
	mock.calls.AddPathConfig = append(mock.calls.AddPathConfig, callInfo)
	mock.lockAddPathConfig.Unlock()
	return mock.AddPathConfigFunc(handler, config)
}

// AddPathConfigCalls gets all the calls that were made to AddPathConfig.
// Check the length with:
//     len(mockedPluginInterface.AddPathConfigCalls())
func (mock *PluginInterfaceMock) AddPathConfigCalls() []struct {
	Handler string
	Config  json.RawMessage
} {
	var calls []struct {
		Handler string
		Config  json.RawMessage
	}
	mock.lockAddPathConfig.RLock()
	calls = mock.calls.AddPathConfig
	mock.lockAddPathConfig.RUnlock()
	return calls
}

// AddSession calls AddSessionFunc.
func (mock *PluginInterfaceMock) AddSession(session sessions.Store) {
	if mock.AddSessionFunc == nil {
		panic("PluginInterfaceMock.AddSessionFunc: method is nil but PluginInterface.AddSession was just called")
	}
	callInfo := struct {
		Session sessions.Store
	}{
		Session: session,
	}
	mock.lockAddSession.Lock()
	mock.calls.AddSession = append(mock.calls.AddSession, callInfo)
	mock.lockAddSession.Unlock()
	mock.AddSessionFunc(session)
}

// AddSessionCalls gets all the calls that were made to AddSession.
// Check the length with:
//     len(mockedPluginInterface.AddSessionCalls())
func (mock *PluginInterfaceMock) AddSessionCalls() []struct {
	Session sessions.Store
} {
	var calls []struct {
		Session sessions.Store
	}
	mock.lockAddSession.RLock()
	calls = mock.calls.AddSession
	mock.lockAddSession.RUnlock()
	return calls
}

// GetHandlerByName calls GetHandlerByNameFunc.
func (mock *PluginInterfaceMock) GetHandlerByName(name string) http.HandlerFunc {
	if mock.GetHandlerByNameFunc == nil {
		panic("PluginInterfaceMock.GetHandlerByNameFunc: method is nil but PluginInterface.GetHandlerByName was just called")
	}
	callInfo := struct {
		Name string
	}{
		Name: name,
	}
	mock.lockGetHandlerByName.Lock()
	mock.calls.GetHandlerByName = append(mock.calls.GetHandlerByName, callInfo)
	mock.lockGetHandlerByName.Unlock()
	return mock.GetHandlerByNameFunc(name)
}

// GetHandlerByNameCalls gets all the calls that were made to GetHandlerByName.
// Check the length with:
//     len(mockedPluginInterface.GetHandlerByNameCalls())
func (mock *PluginInterfaceMock) GetHandlerByNameCalls() []struct {
	Name string
} {
	var calls []struct {
		Name string
	}
	mock.lockGetHandlerByName.RLock()
	calls = mock.calls.GetHandlerByName
	mock.lockGetHandlerByName.RUnlock()
	return calls
}

// Ensure, that PluginLoaderInterfaceMock does implement service.PluginLoaderInterface.
// If this is not the case, regenerate this file with moq.
var _ service.PluginLoaderInterface = &PluginLoaderInterfaceMock{}

// PluginLoaderInterfaceMock is a mock implementation of service.PluginLoaderInterface.
//
//     func TestSomethingThatUsesPluginLoaderInterface(t *testing.T) {
//
//         // make and configure a mocked service.PluginLoaderInterface
//         mockedPluginLoaderInterface := &PluginLoaderInterfaceMock{
//             GetPluginFunc: func(fileName string) (service.PluginInterface, error) {
// 	               panic("mock out the GetPlugin method")
//             },
//             GetRepositoryFunc: func(fileName string) (service.RepositoryInterface, error) {
// 	               panic("mock out the GetRepository method")
//             },
//         }
//
//         // use mockedPluginLoaderInterface in code that requires service.PluginLoaderInterface
//         // and then make assertions.
//
//     }
type PluginLoaderInterfaceMock struct {
	// GetPluginFunc mocks the GetPlugin method.
	GetPluginFunc func(fileName string) (service.PluginInterface, error)

	// GetRepositoryFunc mocks the GetRepository method.
	GetRepositoryFunc func(fileName string) (service.RepositoryInterface, error)

	// calls tracks calls to the methods.
	calls struct {
		// GetPlugin holds details about calls to the GetPlugin method.
		GetPlugin []struct {
			// FileName is the fileName argument value.
			FileName string
		}
		// GetRepository holds details about calls to the GetRepository method.
		GetRepository []struct {
			// FileName is the fileName argument value.
			FileName string
		}
	}
	lockGetPlugin     sync.RWMutex
	lockGetRepository sync.RWMutex
}

// GetPlugin calls GetPluginFunc.
func (mock *PluginLoaderInterfaceMock) GetPlugin(fileName string) (service.PluginInterface, error) {
	if mock.GetPluginFunc == nil {
		panic("PluginLoaderInterfaceMock.GetPluginFunc: method is nil but PluginLoaderInterface.GetPlugin was just called")
	}
	callInfo := struct {
		FileName string
	}{
		FileName: fileName,
	}
	mock.lockGetPlugin.Lock()
	mock.calls.GetPlugin = append(mock.calls.GetPlugin, callInfo)
	mock.lockGetPlugin.Unlock()
	return mock.GetPluginFunc(fileName)
}

// GetPluginCalls gets all the calls that were made to GetPlugin.
// Check the length with:
//     len(mockedPluginLoaderInterface.GetPluginCalls())
func (mock *PluginLoaderInterfaceMock) GetPluginCalls() []struct {
	FileName string
} {
	var calls []struct {
		FileName string
	}
	mock.lockGetPlugin.RLock()
	calls = mock.calls.GetPlugin
	mock.lockGetPlugin.RUnlock()
	return calls
}

// GetRepository calls GetRepositoryFunc.
func (mock *PluginLoaderInterfaceMock) GetRepository(fileName string) (service.RepositoryInterface, error) {
	if mock.GetRepositoryFunc == nil {
		panic("PluginLoaderInterfaceMock.GetRepositoryFunc: method is nil but PluginLoaderInterface.GetRepository was just called")
	}
	callInfo := struct {
		FileName string
	}{
		FileName: fileName,
	}
	mock.lockGetRepository.Lock()
	mock.calls.GetRepository = append(mock.calls.GetRepository, callInfo)
	mock.lockGetRepository.Unlock()
	return mock.GetRepositoryFunc(fileName)
}

// GetRepositoryCalls gets all the calls that were made to GetRepository.
// Check the length with:
//     len(mockedPluginLoaderInterface.GetRepositoryCalls())
func (mock *PluginLoaderInterfaceMock) GetRepositoryCalls() []struct {
	FileName string
} {
	var calls []struct {
		FileName string
	}
	mock.lockGetRepository.RLock()
	calls = mock.calls.GetRepository
	mock.lockGetRepository.RUnlock()
	return calls
}
