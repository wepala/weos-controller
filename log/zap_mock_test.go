// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package logs

import (
	"sync"
)

// Ensure, that ZapInterfaceMock does implement ZapInterface.
// If this is not the case, regenerate this file with moq.
var _ ZapInterface = &ZapInterfaceMock{}

// ZapInterfaceMock is a mock implementation of ZapInterface.
//
// 	func TestSomethingThatUsesZapInterface(t *testing.T) {
//
// 		// make and configure a mocked ZapInterface
// 		mockedZapInterface := &ZapInterfaceMock{
// 			InfoFunc: func(args ...interface{})  {
// 				panic("mock out the Info method")
// 			},
// 			InfofFunc: func(format string, args ...interface{})  {
// 				panic("mock out the Infof method")
// 			},
// 		}
//
// 		// use mockedZapInterface in code that requires ZapInterface
// 		// and then make assertions.
//
// 	}
type ZapInterfaceMock struct {
	// InfoFunc mocks the Info method.
	InfoFunc func(args ...interface{})

	// InfofFunc mocks the Infof method.
	InfofFunc func(format string, args ...interface{})

	// calls tracks calls to the methods.
	calls struct {
		// Info holds details about calls to the Info method.
		Info []struct {
			// Args is the args argument value.
			Args []interface{}
		}
		// Infof holds details about calls to the Infof method.
		Infof []struct {
			// Format is the format argument value.
			Format string
			// Args is the args argument value.
			Args []interface{}
		}
	}
	lockInfo  sync.RWMutex
	lockInfof sync.RWMutex
}

// Info calls InfoFunc.
func (mock *ZapInterfaceMock) Info(args ...interface{}) {
	if mock.InfoFunc == nil {
		panic("ZapInterfaceMock.InfoFunc: method is nil but ZapInterface.Info was just called")
	}
	callInfo := struct {
		Args []interface{}
	}{
		Args: args,
	}
	mock.lockInfo.Lock()
	mock.calls.Info = append(mock.calls.Info, callInfo)
	mock.lockInfo.Unlock()
	mock.InfoFunc(args...)
}

// InfoCalls gets all the calls that were made to Info.
// Check the length with:
//     len(mockedZapInterface.InfoCalls())
func (mock *ZapInterfaceMock) InfoCalls() []struct {
	Args []interface{}
} {
	var calls []struct {
		Args []interface{}
	}
	mock.lockInfo.RLock()
	calls = mock.calls.Info
	mock.lockInfo.RUnlock()
	return calls
}

// Infof calls InfofFunc.
func (mock *ZapInterfaceMock) Infof(format string, args ...interface{}) {
	if mock.InfofFunc == nil {
		panic("ZapInterfaceMock.InfofFunc: method is nil but ZapInterface.Infof was just called")
	}
	callInfo := struct {
		Format string
		Args   []interface{}
	}{
		Format: format,
		Args:   args,
	}
	mock.lockInfof.Lock()
	mock.calls.Infof = append(mock.calls.Infof, callInfo)
	mock.lockInfof.Unlock()
	mock.InfofFunc(format, args...)
}

// InfofCalls gets all the calls that were made to Infof.
// Check the length with:
//     len(mockedZapInterface.InfofCalls())
func (mock *ZapInterfaceMock) InfofCalls() []struct {
	Format string
	Args   []interface{}
} {
	var calls []struct {
		Format string
		Args   []interface{}
	}
	mock.lockInfof.RLock()
	calls = mock.calls.Infof
	mock.lockInfof.RUnlock()
	return calls
}
